<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Dual domain nature of Computer Science | defPhil</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">defPhil</a></li>
      
      <li><a href="/post/">blog</a></li>
      
      <li><a href="/tags/">tags</a></li>
      
      <li><a href="/about/">about me</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h3><span class="title">Dual domain nature of Computer Science</span></h3>
<p class="date">2018/05/04</p>
</div>

<main>
<h2 id="learning-struggles">Learning struggles</h2>

<p>Today, on my way home I was listening to <a href="http://www.case-podcast.org/20-problem-solving-and-clojure-19-with-rich-hickey" title="CaSE">CaSE</a> podcast, who's guest was none other than Rich Hickey. For the biggest part of podcast he was talking about some really cool technological things that we can expect in near future in Clojure ecosystem. I recommend anyone familiar with Clojure or ClojureScript to listen to this episode, I always like hearing Rich talk. But the meatiest part that got me thinking was near the end, probably last twenty minutes of this episode. Conversation was naturally going from Clojure spec to test driven methodologies and practices. Then Rich said something very interesting. I will paraphrase it.</p>

<blockquote>
<p>
Most of the teams don't even know what is the problem that they are trying to solve. They jump straight to coding and implementing solutions without carefully thinking what they want to achieve, and later on they find themselves in many problems. For those interested in studying and working in Computer Science it often comes down to working in multiple domains. First domain is typical Computer Science domain, where you learn about algorithms, data, computers, math and stuff like that, and the other domain(s) where you apply that knowledge to solve something that makes impact in real world, whether it's health and hospitals, schools, bars, banks... But often young people that came straight out of college think and waste so much of brain time on implementations and concrete technology in which they are working, that many aspects and things of concrete problem and model are often left overlooked.
</p>
</blockquote>

<p><strong><strong>Bullseye!</strong></strong> Rich explained it very well in just 5 minutes, and it's something that happened to bother me for quite some time. I often grow tired of investing into technology. For years it felt like I am learning concrete concepts or technologies, which I will transform into patterns and later apply them, with very little awareness, understanding and thinking about real problem that I am trying to solve. Until working in Lisp, everything I learned felt like that. When I started learning Lisp it felt like I had to unlearn quite some amount, and do things little differently. Functional programming kinda gets out of your way. If you understand basic mathematics and its principles (but really understand them, without tricking yourself that you understand something that is quite unclear to you in reality), things just get out of your way. Functional programming feels natural and lets you focus on what matters, and that's having your code affecting real world in as less abstraction and amount of it being written as possible.</p>

<h2 id="eager-to-learn-but-maybe-moving-too-fast">Eager to learn, but maybe moving too fast</h2>

<p>I am still a student. I am having few hobbies, but solid amount of my free time I spend in front of the computer or book reading/writing code, reading about creating and maintaining computer programs and similar stuff. I want to try everything (not literally, but I have gone from assembly/OS level code to high level Python code). I wanted to use the time on college to learn as much as I can about computers, see where I find myself most entertained and hyped to work on something, try many esoteric technologies that I find fun and interesting. Actually, back in that podcast I talked you about few minutes ago, Rich mentioned that he recommends reading old CS papers (60s, 70s), where people designed technologies along with systems, and those systems were meant to achieve something in real world. 98% of those things are forgotten and not used in present, but they influenced many ideas and things that we use today to create software and change the world around us. And I've written in some previous blog post about those people back then, and how impressed I was by their thought process and perception of reality and nature.</p>

<p>In the end all of this is fine and dandy, but sometimes I feel like I am lost and that I won't ever achieve greatness (in self actuation terms). Feels like I still haven't found the thing. I like writing lower level software, but building and designing systems can be fun too. Plus if you are using some interesting functional programming language to create that system, even better. Many people tell me it's ok to experiment and try everything, I am still learning and now is the time to do that, but seeing other young people finding their way around all that technology fluff and applying their skills to something impactful to the real world is what drives me down every time.</p>

<p>--</p>

<p>Maybe in the end I don't have enough knowledge to use it in computer science domain to create something that will change the world outside of my personal computer, or maybe I am just pushing myself down as part of some kind of insecurity or imposter syndrome. Or I am just trippin' balls cause I went all over the place, learned many things without going deep enough to settle down and do something meaningful. Either way, I really recommend everyone to listen to this podcast I posted in above. Now I have to get back to reading "Joy of Clojure", after which I will write some Rust... (<em>sigh</em>)</p>

</main>

  <footer>
  
  
  <hr/>
  <a href="http://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC</a> unless stated otherwise | Filip Miletic 2018 | <a href="https://github.com/defphil">Github</a> | <a href="https://twitter.com/defnphil">Twitter</a>
  
  </footer>
  </body>
</html>

