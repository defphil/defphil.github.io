<!DOCTYPE html>
<html>
<head>

  <meta charset="UTF-8">
  <title>phlm - blog</title>
  <meta name="viewport" content="width=device-width">
  <!--[if lt IE 9]>
  <![endif]-->
  <link href="/assets/css/style.css" rel="stylesheet" />
  <link href="/assets/css/colors-dark.css" rel="stylesheet" />
</head>

<body>



  <header id="header">
    <h1><a href="/"> /dev/phlm</a></h1>
    <p>another blog on the internet</p>
  </header>



  <div id="page">



    <div id="sidebar">
      <nav>
        <ul>
          <li><a href="/">home</a></li>
          <li><a href="/archives">archive</a></li>
          <li><a href="/about">about</a></li>
          <li><a href="/feed.xml">rss</a></li>
        </ul>
      </nav>
    </div>
    <div id="content">
      

	<article class="post">

		
			<h1><a href="/2019/03/20/interim-tech-report/">Interim tech report for last 6 months</a></h1>
		

		<div class="post-content"><p>With this post, I wanted to recap what changes I’ve introduced to my digital
life, on and offline. In general, I removed and deleted most of things. Went
back to open source software, standardized formats that work everywhere(txt),
reduced my iPhone usage… So lets start:</p>

<ul>
  <li>
    <p>I deleted Facebook. (Which I had from 2007. to 2012. and from 2015. until this
moment)</p>
  </li>
  <li>
    <p>I deleted Instagram. I realized I was not looking at the content I wanted and
followed, but Facebook was serving me too much ads and content I really didn’t
care about, so I found out there was no point in having it.</p>
  </li>
  <li>
    <p>I deleted Whatsapp. This will be related to next point.</p>
  </li>
  <li>
    <p>Most of my friends (like 80%) now have <code>Telegram</code>, which I’ve been using
from 2015. So I am really happy I have everyone covered with iMessage and
Telegram.</p>
  </li>
  <li>
    <p>I’ve deleted my main Twitter account and created empty one where I follow just
people that have something interesting to say (mostly developers that don’t
tweet about politics, so I use Twitter like some kind of RSS service)</p>
  </li>
  <li>
    <p>I’ve deleted a lot of websites from my elfeed feed in Emacs.</p>
  </li>
  <li>
    <p>Moved all my notes to <code>org-mode</code>. This one is simple. I’ve already
been using vim and Emacs for almost 10 years now. Org is essentially plain
text, and nice iOS companion app <code>beorg</code> is providing me with sleek
overview ehen I do not have my MacBook with me (which is rare but still).</p>
  </li>
  <li>
    <p>I’ve deleted bunch of podcasts. I realized I was cluttering myself and
listening to a lot of shit that I used as background noise.</p>
  </li>
  <li>
    <p>Reduced my time on YouTube. No longer do I spend 3 hours watching some stupid
videos.</p>
  </li>
  <li>
    <p>Back to using pen and paper for brainstorming and sketching ideas. I found out
that this process feels much more natural for me. No need for fancy graphing
software and sketches, so I dropped omnigraffel for real thing.</p>
  </li>
  <li>
    <p>I’ve moved to <code>Firefox</code>. Now this is the tricky one. Chrome was not
an option. Despite being more performant I just cannot use Google’s browser
in 2019. Google is not what it used to be. And I get it. In the end it is all
a matter of choice. I don’t like the state in which web is today. Future of
internet is grim, and I decided to support open source, decentrilized web. Now
Mozilla is not a saint either, I do not like how they are forcing options and
adding stupid stuff into browser, but in the end I always manage to disable
things. Now the question is why I moved from Safari on macOS (since I still
use it on iPhone). DevTools. I find Safari unbearable when doing web
development. I just can’t stand it. Although I prefer Chrome the most in terms
of development tools, Firefox is tad different, but very usable &amp; powerful.</p>
  </li>
  <li>
    <p>I ditched iTerm for <code>Terminal.app</code>. Since I started appreciating default vim
config with slight ajustments it just felt much smoother and responsive. I
hate input lag when I’m programming. Although iTerm2 is much better with new
renderer, something about Terminal.app feels really right (font rendering and
input latency I guess).</p>
  </li>
  <li>
    <p>I started using <code>Pinboard</code>. Oh god. If everything on the web could
be built this way.</p>
  </li>
  <li>
    <p>I am testdriving Drew DeVault’s <code>sourcehut</code> as a replacement for
Github. This is Pinboard of online git repo hosting. GitLab is slow with bad
UI/UX. Sourcehut implements Unix philosophy, it is open source and very
pragmatic and sturdy.</p>
  </li>
  <li>
    <p>I’m trying out <code>micro.blog</code>. I like the community so far. A lot of
mature and smart people. Every day I can read some interesting conversation. I
like it a lot.</p>
  </li>
  <li>
    <p>I do once a week encrypted <code>TimeMachine</code> backups. Bought really
nice USB 3.1 SanDisk 128gb flash drive, using it as storage for music and backups.</p>
  </li>
</ul>

<p>I think I will stop here. Last year or so was pretty cathartic in terms of how I
looked at services and the way I use computer everyday. Use open well
standardized formats, open source code is prefered. I found nice balance of
productivity which macOS provides and open source software (brew, emacs, vim,
git, mutt, firefox…) <em>Wake up people! We need to fight for open, transparent
and decentralized internet!</em> Start from your own machines and usages. Don’t give
away information to others so easily just because they offer you something for
free. Don’t be a product.</p>
</div>

	</article>



	<article class="post">

		
			<h1><a href="/2019/01/28/perception-clojure/">Change of perception thanks to Clojure</a></h1>
		

		<div class="post-content"><p>It’s been quite some time since I wrote Clojure, probably around 2 months or
so. I stumbled upon <a href="http://ecmendenhall.github.io/blog/blog/2013/09/05/clean-clojure-functions/"><span class="underline">this</span></a> blogpost by Connor Mendenhall. Reading it carefully
without skimming is really recommended, and fun. It inspired me enough to write
my first blogpost in 2019.</p>

<p>My first introduction to functional programming was through Scheme and SICP (I
am re-reading this book for few years now, it never stops to amaze me). This
would be the core concept that would slap me from the back of the head when I
started getting my feet wet with Clojure. Whole process of writing code
alongside REPL, coming back to it, reiterating it, making it more idiomatic,
achieving more with much less code that is more readable,  all of those things
are core concepts of SICP, which I didn’t get on my first tries. Going through
book again felt very rewarding and made my efforts in functional programming
that more rewarding .</p>

<p>In this blogpost we can see usual way of writing functional code. 
Immutable data + small and clean (not always pure) functions, and
whole process of achieving that through some weird but natural way of splitting
things apart while working alongside REPL. Yeah, a lot of concepts in one sentence,
but that’s all there is to it, and it is really simple when you get what each of
those concepts mean and what they stand for.</p>

<p>I consider every functional language to be kind of a different beast. Core
concepts are the same, and if you get that, big chances are you will peak on the
other side of some other interesting and exotic language (and if you are reading
this blogpost I am sure you are <span class="underline">that</span> kind of person to begin with). Haskell is
notorious by it’s type system, Common Lisp by it’s flexibility of writing
imperative/functional code and it’s meta-programming capabilities, Erlang about
it’s concurrency, and Clojure? Clojure is data oriented language. And it blew my
mind! It totally changed the way how I perceive abstractions and write code.</p>

<p>How Clojure achieves that special layer of abstraction between underlying data
and clean Lisp-like syntax is through literals and core concepts like
immutability. After enough staring at different parentheses, letters and
symbols, you get the sense of what is what, and what fits where. 
And then everything snaps right in front of your eyes. 
It feels like you almost see the data flowing through code. By carefully
writing small decoupled functions (again, <em>read the blogpost which represents
very nicely how code evolves from something big and clunky, to something very
idiomatic, easy to maintain and read</em>), top to bottom, breaking problems into
very small pieces. And how you move down the buffer of your favourite text
editor (<em>:cough:</em> Emacs <em>:cough:</em>) you see those small and nice functions that do
only one thing combined with each other, on top of immutable data, state of your
data becomes much clearer, you get the sense about what is happening in your own
program. The whole process of reiterating through code, making it more how
Clojure code is meant to be simply rewards you with clean and robust end
result. You can see on Github a bunch of libraries that haven’t been touched for
years, but don’t let that fool you, they aren’t dead, they just don’t need to be
touched. They work how they should, people are using them and don’t think about
them anymore. Only language where I’ve seen this is the same case is Common
Lisp, maybe even more fascinating in that regard than Clojure, but that’s for
different topic.</p>

<p>Now things aren’t that fine and dandy in the beginning. I had a luck that I
was exposed to Emacs much earlier than I began working with Clojure. I can’t
imagine writing Clojure (and any other functional or REPL-based language) in
any other environment (Cursive is great, go check it out, but I use IntelliJ 
only for Java). But my main hurdle with Clojure was <em>way of doing things right</em>. I
still consider myself an amateur Clojurist, I don’t have any real world
full-time job experience with Clojure, but in the beginning I felt really
overwhelmed. I was overthinking my every step, and was getting confused by
possibility of doing one thing on N different ways.</p>

<p><em>Should I use multidimensional
vector, or map? How do I achieve X-thing without iterating through whole set?
Should I rewrite this big function using multimethods or separate them completely?</em></p>

<p><strong>Getting Clojure</strong> by <a href="http://russolsen.com">Russ Olsen</a> helped me tremendously with all those questions
 that made me rethink my every step. And solution for this kind of problem was
 very simple as always… write. more. Clojure. code. With all that out of the
 way, I had my favourite language. When I had to do some work in Java, or C I
 was always thinking about how elegant and how pragmatic whole Clojure landscape is. I want it to be adopted more, language itself is very
 opinionated and that could be problem to a wider adoption, but after that
 initial period of struggling with a lot of new concepts I appreciated every bit
 about it. And I’ve met a lot of people doing really cool stuff with
 Clojure. Like for example mind-bending stuff from <a href="http://brutalism.rs">Vladimir Mitrovic</a>, or less
 artistic and more scientific efforts from <a href="https://dragan.rocks">Dragan Djuric</a> and his work in Data
 Science/ML/High Performance Computing.</p>

<p>I can really see myself using Clojure just for sake of using it. Hobby project
here and there for now. But I would really like to make a living out of it when
I gain more experience as developer. Until then I will work hard to be better at
it.</p>

<p>Clojure and it’s ecosystem feel modern, refreshing and sophisticated. As it grows more
mature and as guys from Cognitect put more efforts into tooling and ecosystem it
is really starting to represent something that we lost along the way of
technological advancement and industrialization of software and
programming.</p>
</div>

	</article>







    </div>
  </div>
  <footer id="footer">
    <p class="copyright"> <a rel="cc by ns" href="http://creativecommons.org/licenses/by/4.0/">cc-by</a> Filip Miletic | 2019 </p>
  </footer>


</body>
</html>
