<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>phlm</title>
    <description>Personal blog space of Filip Miletic, open source developer and student</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 14 Mar 2019 19:23:53 +0100</pubDate>
    <lastBuildDate>Thu, 14 Mar 2019 19:23:53 +0100</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>Curing myself from config disease</title>
        <description>&lt;h2 id=&quot;i-confess-i-was-config-freak&quot;&gt;I confess, I was config freak&lt;/h2&gt;

&lt;p&gt;Since early days of high school I was sinking significant amount of time into writing my own scripts and configs that didn’t made much impact on anything except my own experience in front of the computer. Amount of knowledge I was getting out of it was probably significantly lower compared to if I had spent that time doing real problem solving or working on some personal project instead. But you know how it goes when you are a kid, you have plenty time on your hand, and at during that period I was exploring wonders of UNIX-like operating systems. Pretty early I decided that Windows was no-go for me. I just didn’t like it. Arch Linux was my thing at a time. Oh boy, I remember the day when I installed Arch for the first time. This time I got everything right. Wifi - check; User account - check; X11 - check; Sound - check; I felt like I’ve accomplished something big. Little did I know that I started chasing the rabbit down the hole.&lt;/p&gt;

&lt;h3 id=&quot;it-was-all-vims-fault&quot;&gt;It was all Vim’s fault&lt;/h3&gt;

&lt;p&gt;In that period of UNIX system exploration I was reinstalling and crashing Linux systems at least once a day. &lt;img align=&quot;right&quot; src=&quot;/assets/img/19-03-14/puke-ss.png&quot; /&gt; So a lot of the time I’ve spent in ‘chroot’ environment of live USB installation, so no GUI. I started getting grasp of Vim since everyone on the internet was recommending it. I introduced myself to it totally spontaneously. Learned command by command, at first I was scratching my head a lot… I thought Bill Joy took some hefty dose of LSD while was designing it… I never saw anything quite similar to it’s modal editing model. First I was like, “wow, this thing is ugly”. I was working previously mostly on Macs, those wonderful Snow Leopard days when Apple was becoming developers’ favorite thing since sliced bread. TextMate was the thing around that time. I was using it lightly since I wasn’t programming anything serious around that time, I was complete beginner. But since I was staying more and more time in terminal, learning Vim was natural thing to do. And I started reading many configs. Copying things which I didn’t understand (we know how that ends), installing plugins, loading custom themes, syntax files, etc… And suddenly after a lot of wasted time playing around with Linux and ricing, I didn’t have anything to do. Everything was pixel-perfect how I wanted. So now what… &lt;em&gt;(Sadly I can’t find screenshots from my setups on /r/unixporn right now)&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;parens-strike-back&quot;&gt;(((Parens strike back)))&lt;/h3&gt;

&lt;p&gt;I installed Emacs. Around that time I decided to give Emacs a shot, I got into Faculty. I was majoring in Electrical Engineering. Didn’t have much free time, it was very tough period, I was studying a lot. But after I’ve finished exams from first few semesters I really started to develop serious obsession with writing software. I wanted to learn functional programming, since I got bored with OOP. I knew if I wanted to grasp real OO knowledge I would need to find a job/internship and work on some bigger then average personal project codebase. So I got into Lisp (scheme to be more precise), and Emacs was like a must. It provided interactive environment with infinite possibilities, you could achieve theoretically anything using that dialect called ELisp. I was very hyped. It seemed that with Emacs my ricing needs will never run out of fuel.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/19-03-14/emacs-ss.png&quot; alt=&quot;My current Emacs setup&quot; title=&quot;Emacs&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;back-to-life-back-to-reality&quot;&gt;Back to life back to reality&lt;/h3&gt;

&lt;p&gt;But the funny thing was that every time I thought I’ve achieved apex with my configurations, I will immediately start decluttering and stripping things off. &lt;em&gt;I hated latency and lag while typing.&lt;/em&gt; I hated it with my gut. I don’t know why but for me startup times of 2 seconds were bane of my existence. I liked light software, when things are simple and responsive, twitchy and as smooth as they can be. Pendulum started going in completely other direction. I kept using both Vim and Emacs, but their configurations were smalled, they included only things I actually used.&lt;/p&gt;

&lt;h4 id=&quot;and-back-to-defaults&quot;&gt;…and back to defaults&lt;/h4&gt;

&lt;p&gt;For last year or so, I was experimenting with syntax highlighting. I found myself disabling it more often than leaving it on. Then I wrote my own themes
which were highlighting most important things in code like keywords, string, comments, numbers and function names. When I started doing some real work I needed my tools to work and get out of the way. No more fancy colors, mode-lines, bold and italic fonts and what not. I started to appreciate standardized formats which were portable (read: pure text files, ahem org-mode). With Vim and Emacs I never have to fear if the thing will die like TextMate did. So my time investment was probably for life. And I came to realization that I made my configurations look really similar to default ones. Minor things are modified for local development environment like FZF and tag navigation and that’s it. I even started using default colorschemes in Vim. All those low contrast themes with bright blue background made me not see anything, it was very tiring for my eyes, and default colors worked the best. I remember very good the discomfort when I SSHd on some machine, opened Vim and I felt really uncomfortable cause it didn’t look anything like I was used to, but the whole point of learning Vim was to have powerful text editor tool under my belt that I can pull out anywhere and work flawlessly.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/19-03-14/vim-ss.png&quot; alt=&quot;Current Vim setup, which I use mostly for terminal work&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now I see a lot of new fancy things getting pretty popular. VSCode is one of them. I give it a shot probably every second or third release, just because I follow Microsoft’s development blog on it. Okay, I forgive slower than usually startup times (it starts slower than my full blown Emacs configuration [okay I optimized it not to load packages which aren’t used in that moment, but still]). I start typing or scrolling folder browser on the left side and I immediately uninstall it. The lag. I can’t really stand it. The bloat everywhere. I get it it strikes perfect balance between IDE and editor. It brought very interesting ideas to the table of development tools with it’s tight integration of Git, debugger and terminal. Developing JS/TS projects make perfect sense, and probably the only use case in which I can see myself going over all that sluggishness. But I am never writing JS as of now. On the other hand, after hour in VSCode I open Sublime Text and I am like, “I am not crazy people, I told you that thing is slow”. Now it is all about what you want and need from your development tools. I like fast tools that gets out of your way. I have to give shout out to Sublime Text, because it is such a nice piece of software that gets job done.&lt;/p&gt;

&lt;p&gt;At this point I feel like I’ve made a full circle. Went through hell and back. But I think I’ve learned a valuable lesson. Fact is that I had a lot of free time for playing with systems, tools and computers. I’ve learned few valuable things about development process and tools. And now I consider myself proficient in two most famous dev. tools, Vim and Emacs.&lt;/p&gt;

</description>
        <pubDate>Thu, 14 Mar 2019 00:00:00 +0100</pubDate>
        <link>/2019/03/14/curing-myself-from-config-disease/</link>
        <guid isPermaLink="true">/2019/03/14/curing-myself-from-config-disease/</guid>
        
        <category>Tools</category>
        
        
      </item>
    
      <item>
        <title>Change of perception with Clojure</title>
        <description>&lt;p&gt;It’s been quite some time since I wrote Clojure, probably around 2 months or
so. I stumbled upon &lt;a href=&quot;http://ecmendenhall.github.io/blog/blog/2013/09/05/clean-clojure-functions/&quot;&gt;&lt;span class=&quot;underline&quot;&gt;this&lt;/span&gt;&lt;/a&gt; blogpost by Connor Mendenhall. Reading it carefully
without skimming is really recommended, and fun. It inspired me enough to write
my first blogpost in 2019.&lt;/p&gt;

&lt;p&gt;My first introduction to functional programming was through Scheme and SICP (I
am re-reading this book for few years now, it never stops to amaze me). This
would be the core concept that would slap me from the back of the head when I
started getting my feet wet with Clojure. Whole process of writing code
alongside REPL, coming back to it, reiterating it, making it more idiomatic,
achieving more with much less code that is more readable,  all of those things
are core concepts of SICP, which I didn’t get on my first tries. Going through
book again felt very rewarding and made my efforts in functional programming
that more rewarding .&lt;/p&gt;

&lt;p&gt;In this blogpost we can see usual way of writing functional code. 
Immutable data + small and clean (not always pure) functions, and
whole process of achieving that through some weird but natural way of splitting
things apart while working alongside REPL. Yeah, a lot of concepts in one sentence,
but that’s all there is to it, and it is really simple when you get what each of
those concepts mean and what they stand for.&lt;/p&gt;

&lt;p&gt;I consider every functional language to be kind of a different beast. Core
concepts are the same, and if you get that, big chances are you will peak on the
other side of some other interesting and exotic language (and if you are reading
this blogpost I am sure you are &lt;span class=&quot;underline&quot;&gt;that&lt;/span&gt; kind of person to begin with). Haskell is
notorious by it’s type system, Common Lisp by it’s flexibility of writing
imperative/functional code and it’s meta-programming capabilities, Erlang about
it’s concurrency, and Clojure? Clojure is data oriented language. And it blew my
mind! It totally changed the way how I perceive abstractions and write code.&lt;/p&gt;

&lt;p&gt;How Clojure achieves that special layer of abstraction between underlying data
and clean Lisp-like syntax is through literals and core concepts like
immutability. After enough staring at different parentheses, letters and
symbols, you get the sense of what is what, and what fits where. 
And then everything snaps right in front of your eyes. 
It feels like you almost see the data flowing through code. By carefully
writing small decoupled functions (again, _read the blogpost which represents
very nicely how code evolves from something big and clunky, to something very
idiomatic, easy to maintain and read_), top to bottom, breaking problems into
very small pieces. And how you move down the buffer of your favourite text
editor (&lt;em&gt;:cough:&lt;/em&gt; Emacs &lt;em&gt;:cough:&lt;/em&gt;) you see those small and nice functions that do
only one thing combined with each other, on top of immutable data, state of your
data becomes much clearer, you get the sense about what is happening in your own
program. The whole process of reiterating through code, making it more how
Clojure code is meant to be simply rewards you with clean and robust end
result. You can see on Github a bunch of libraries that haven’t been touched for
years, but don’t let that fool you, they aren’t dead, they just don’t need to be
touched. They work how they should, people are using them and don’t think about
them anymore. Only language where I’ve seen this is the same case is Common
Lisp, maybe even more fascinating in that regard than Clojure, but that’s for
different topic.&lt;/p&gt;

&lt;p&gt;Now things aren’t that fine and dandy in the beginning. I had a luck that I
was exposed to Emacs much earlier than I began working with Clojure. I can’t
imagine writing Clojure (and any other functional or REPL-based language) in
any other environment (Cursive is great, go check it out, but I use IntelliJ 
only for Java). But my main hurdle with Clojure was &lt;em&gt;way of doing things right&lt;/em&gt;. I
still consider myself an amateur Clojurist, I don’t have any real world
full-time job experience with Clojure, but in the beginning I felt really
overwhelmed. I was overthinking my every step, and was getting confused by
possibility of doing one thing on N different ways.&lt;/p&gt;

&lt;p&gt;/Should I use multidimensional
vector, or map? How do I achieve X-thing without iterating through whole set?
Should I rewrite this big function using multimethods or separate them completely?/&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Getting Clojure&lt;/strong&gt; by &lt;a href=&quot;http://russolsen.com&quot;&gt;Russ Olsen&lt;/a&gt; helped me tremendously with all those questions
 that made me rethink my every step. And solution for this kind of problem was
 very simple as always… write. more. Clojure. code. With all that out of the
 way, I had my favourite language. When I had to do some work in Java, or C I
 was always thinking about how elegant and how pragmatic whole Clojure landscape is. I want it to be adopted more, language itself is very
 opinionated and that could be problem to a wider adoption, but after that
 initial period of struggling with a lot of new concepts I appreciated every bit
 about it. And I’ve met a lot of people doing really cool stuff with
 Clojure. Like for example mind-bending stuff from &lt;a href=&quot;http://brutalism.rs&quot;&gt;Vladimir Mitrovic&lt;/a&gt;, or less
 artistic and more scientific efforts from &lt;a href=&quot;https://dragan.rocks&quot;&gt;Dragan Djuric&lt;/a&gt; and his work in Data
 Science/ML/High Performance Computing.&lt;/p&gt;

&lt;p&gt;I can really see myself using Clojure just for sake of using it. Hobby project
here and there for now. But I would really like to make a living out of it when
I gain more experience as developer. Until then I will work hard to be better at
it.&lt;/p&gt;

&lt;p&gt;Clojure and it’s ecosystem feel modern, refreshing and sophisticated. As it grows more
mature and as guys from Cognitect put more efforts into tooling and ecosystem it
is really starting to represent something that we lost along the way of
technological advancement and industrialization of software and
programming.&lt;/p&gt;

</description>
        <pubDate>Mon, 28 Jan 2019 00:00:00 +0100</pubDate>
        <link>/2019/01/28/change-of-perception-clojure/</link>
        <guid isPermaLink="true">/2019/01/28/change-of-perception-clojure/</guid>
        
        <category>Clojure</category>
        
        
      </item>
    
  </channel>
</rss>
